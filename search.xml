<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>UML类图简介</title>
      <link href="/2020/04/15/design-pattern-2020-04-15-UML%E7%AE%80%E4%BB%8B/"/>
      <url>/2020/04/15/design-pattern-2020-04-15-UML%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>讲道理，<code>UML</code>总在接触，但是每次看到实在打不起兴趣好好看，总觉得略显复杂，就没有看下去的欲望，后来发现设计模式越学图越多，拉倒吧，那就记录一下这<code>UML</code>到底是个什么玩意。</p><h1 id="什么是-UML"><a href="#什么是-UML" class="headerlink" title="什么是 UML"></a>什么是 UML</h1><p><strong>统一建模语言</strong>（<code>Unified Modeling Language</code>，缩写 <code>UML</code>）是非专利的第三代<a href="https://zh.wikipedia.org/w/index.php?title=对象建模语言&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">建模</a>和<a href="https://zh.wikipedia.org/wiki/规约语言" target="_blank" rel="noopener">规约语言</a>。<code>UML</code>是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。<code>UML</code>展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在<a href="https://zh.wikipedia.org/wiki/软件架构" target="_blank" rel="noopener">软件架构</a>层次已经被验证有效。</p><blockquote><p>摘自维基百科</p></blockquote><p><code>UML</code>是用来设计软件蓝图的可视化建模语言，<code>1997</code> 年被国际对象管理组织(<code>OMG</code>)采纳为面向对象的建模语言的国际标准。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p>乍一看，觉得还是挺抽象的，其实简单来说，就是用一种图形化的语言来对软件中对象关系进行建模，<code>UML</code>从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等<code>9</code>种图。</p><p>这里只介绍类图，毕竟作为<code>Java coder</code>，其他的也不咋太关心，有兴趣的就自行了解其他的吧。</p><h1 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h1><p>我们结合着一个简单的<code>Java</code>类来说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(Double salary)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要用<code>UML</code>表示这样一个类，该怎么画呢：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E7%B1%BB.jpg" alt="UML类" style="zoom:50%;"></p><p>这就是一个最简单的<code>UML</code>类图了，下面我们来具体看看图上都有些个啥。</p><h2 id="访问限定符"><a href="#访问限定符" class="headerlink" title="访问限定符"></a>访问限定符</h2><p>可以看到，图上有一些<code>+、-</code>这些是啥呢，这个其实就是类图中用来表示访问限定符的，有以下常用的限定符：</p><ul><li><code>+</code>：表示<code>public</code></li><li><code>-</code>：表示<code>private</code></li><li><code>#</code>：表示<code>protected</code></li><li><code>~</code>：表示<code>default</code></li><li><code>_</code>：表示<code>static</code></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>上面这张图，也就对应了一个<code>Java</code>类<code>User</code>，我们可以看到它分了三个部分即</p><ul><li><p>类名：是一个字符串，对应我们的<code>Java</code>类名</p></li><li><p>属性：指类具备的一些属性，也就是我们说的类中的成员变量，它一般用以下格式表示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性] 属性名:类型[=默认值] // 默认值可有可无</span><br></pre></td></tr></table></figure></li><li><p>方法：也称为操作，它指的是类对象的一些行为，即类的成员方法，它可以这么表示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[可见性] 名称(参数列表):[返回值类型]</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>那接口怎么表示呢，我们看这样一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getSalary</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准的<code>UML</code>图中我们用一个圆和横线来表示，如下图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E6%8E%A5%E5%8F%A31.jpg" alt="UML接口1" style="zoom:50%;"></p><p>但是在更多的使用中，我们还会用如下方式：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E6%8E%A5%E5%8F%A32.jpg" alt="UML接口2" style="zoom:50%;"></p><p>这里类似上面的类，只是用<code>&lt;&lt;interface&gt;&gt;</code>来表示接口，同时没有属性列表。</p><h1 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h1><p>在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，<code>UML</code> 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现关系便是<code>Java</code>中的类实现接口的这种实现关系，它的表示方法与泛化关系类似，只是它所用的是虚线，比如我们的<code>JavaCoder</code>是一个员工接口<code>Employee</code>的实现，表示如下图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E5%AE%9E%E7%8E%B0.jpg" alt="UML实现" style="zoom:50%;"></p><h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>泛化关系其实就是我们<code>Java</code>中的继承关系，它的表示方法就是，用实线和空心三角形，由子类指向其被继承的父类，比如<code>JavaCoder</code>是<code>Coder</code>的子类，表示如下图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E6%B3%9B%E5%8C%96.jpg" alt="UML泛化" style="zoom:50%;"></p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>依赖关系是一种较弱的关系，这种关系是指比如在局部变量、方法参数、静态方法调用等等这类方式使用其他类中的某些方法来完成某些功能。比如，作为一个搬砖工的我想加工资了，那么我需要用电脑发个邮件申请，这就可以理解为一种依赖关系。那么如何表示这种关系呢，就是用一个带箭头的虚线，由依赖者指向被依赖者，表示如下图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E4%BE%9D%E8%B5%96.jpg" alt="UML依赖" style="zoom:50%;"></p><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><p>关联关系则强于依赖关系，他表示对象之间的关系是一种引用关系。关联关系又分为一般关联关系、聚合、组合。</p><h3 id="一般关联关系"><a href="#一般关联关系" class="headerlink" title="一般关联关系"></a>一般关联关系</h3><p>一般的关联关系即是对象存在一种引用关系，而这种关系可以是相互的也可以是单向的。就是可以是双向关联关系，也可以是单向关联关系。比如一个咱程序汪属于某个部门，但是并不是每个部门都有程序汪，这可以理解为一种单向关联关系。再比如你今天高兴带了个实习生，那么你们之间相互产生关系，则可以理解为一种双向关联关系。单向关联用实线带箭头，由关联着指向被关联者来表示，而双向关联则是没有箭头的实线来表示，如下图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94.jpg" alt="UML双向关联" style="zoom:50%;"></p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94.jpg" alt="UML单向关联" style="zoom:50%;"></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>聚合是另一种关联关系，它是一种整体与部分的关系，比如员工之于公司，公司没了换家咱还是那个熟悉的程序汪不是，那么这种关系该如何表示呢，用空心菱形加实线，由部分指向整体，如下图所示：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E8%81%9A%E5%90%88.jpg" alt="UML聚合" style="zoom:50%;"></p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合是一种更强的关联关系，他也是一种部分与整体的关系，但是部分不能脱离整体而存在。比如这天你又想加薪了，准备写邮件申请，总得用手写吧，手总不能自己独立去写吧，不然想想也怪可怕的。他的表示与聚合类似，只是用的为实心菱形。如下图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/Design%20Pattern/UML_%E7%BB%84%E5%90%88.jpg" alt="UML组合" style="zoom:50%;"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这里只是介绍了<code>UML</code>图中的类图，且只是介绍了常用的一些，更多的用法需要再实际使用过程中慢慢积累了。</p><blockquote><p>参考维基百科</p></blockquote>]]></content>
      
      <categories>
          
          <category> Design Pattern </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Design Pattern </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java内存模型(JMM)</title>
      <link href="/2020/04/08/java-2020-04-08-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/"/>
      <url>/2020/04/08/java-2020-04-08-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-JMM/</url>
      <content type="html"><![CDATA[<p>在并发编程中，需要处理两个关键问题：线程之间如何通信以及线程之间如何同步。</p><ul><li>通信：是指线程之间以何种机制来进行信息交换。在命令式编程中有两种方式进行通信，即共享内存和消息传递。共享内存是通过内存中的共享状态来进行隐式通信，而消息传递是通过发消息来进行显式通信。</li><li>同步：是指程序中用于控制不同线程执行顺序的机制。在共享内存的并发模型中，线程同步是显式进行的，需要程序员指定方法或代码块在线程间互斥执行，在消息通信的并发模型中，同步是隐式进行的，因为发消息必然要在收消息之前。</li></ul><p><code>Java</code>的并发采用的是共享内存模型。</p><h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p><code>JMM(Java Memory Model)</code>内存模型定义了共享内存系统中多线程程序读写操作的行为规范，来屏蔽各种和操作系统内存访问的差异，来实现<code>Java</code>程序在各个平台下都能达到一致性的内存访问效果。<code>JMM</code>的主要目标是定义程序中各个变量的访问规则，也就是在虚拟机中将变量(这里的变量是指共享变量，即实例域，静态域和数组元素，局部变量是线程私有的，不会共享，也不受<code>Java</code>内存模型的影响)存储到内存以及从内存中取出变量这类的底层细节。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。它解决了<code>CPU</code>多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的可见性、原子性和有序性。内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。</p><p><code>JMM</code>定义了线程和内存的交互方式，在<code>JMM</code>抽象模型中，分为主内存、工作内存。主内存是所有线程共享的，工作内存是每个线程独有的。线程对变量的所有操作(读取、赋值)都必须在工作内存中进行，不能直接读写主内存中的变量。并且不同的线程之间无法访问对方工作内存中的变量，线程间的变量值的传递都需要通过主内存来完成，他们三者的交互关系如下：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92.jpg" alt="JMM"></p><p>总的来说，<code>JMM</code>是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会 对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p><h1 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h1><p>很多时候，指令执行的顺序并不是按照我们写代码的顺序执行的，在单线程下语义不变情况下，为了提高性能，处理器，编译器等都会对指令进行重新排序，让我们觉得指令是按照顺序执行的。重排序分为三种：</p><ul><li>编译器优化的重排序。编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序。</li><li>指令集并行的重排序。现代计算机多采用了指令集并行技术来将多条指令并行执行，如果不存在数据依赖，处理器可以改变语句对应处理器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是乱序的。</li></ul><p>从<code>Java</code>源代码到最终执行的指令集，可能会经历如下步骤：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/%E6%BA%90%E7%A0%81%E7%BB%8F%E9%87%8D%E6%8E%92%E5%BA%8F%E5%88%B0%E6%8C%87%E4%BB%A4%E9%9B%86.jpg" alt="Java源代码到指令集"></p><p>这三种重排序，第一种为编译器的重排序，后两种属于处理器的重排序，<code>JMM</code>对于这两种类型的重排序分别有对应的策略，对于编译器的重排序，<code>JMM</code>的编译器重排序规则会禁止特定类型的编译器重排序(并不是所有)，而对于处理器的重排序，则<code>JMM</code>规则会在编译器生成指令序列的时候，插入内存屏障(<code>Memory Barriers</code>或<code>Memory Fence</code>)，通过内存屏障来禁止特定类型的处理器重排序。</p><p><code>JMM</code>是语言级别的内存模型，它保证了在不同的编译器和不同的处理器上，通过禁止特定类型的编译器和处理器重排序，为程序员提供一致的内存可见性保证。</p><h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1><p>现代计算机多采用多核心处理器，且每个处理器有自己的高速缓冲区，由于<code>CPU</code>处理速度与主存处理速度存在巨大差距，所以采用多级缓存来提高性能，保证指令流水线可以持续执行，避免处理器停顿下来等待与主存交换数据。这样做的弊端也很明显，即缓存并不是实时与主存发生交互，可能出现多个缓存不一致的问题，从而给程序带来一些问题。而内存屏障正是用来解决这一问题的。</p><p>硬件层面内存屏障分为两种：<code>Load Barriers</code>和<code>Store Barriers</code>，<code>Load</code>顾名思义加载，<code>Store</code>储存，也就是读屏障和写屏障。读屏障可以使缓存失效，强制从主存重新<code>Load</code>数据。写屏障是强制将更新的数据<code>Store</code>入主存，使其他缓存无效，可以看到新的值。</p><p>内存屏障一方面通过禁止屏障前后的指令重排序，另一方面可以通过强制<code>Load</code>和<code>Store</code>来保证可见性。</p><p>在<code>JMM</code>中一共有四种类型的屏障，其实也是通过以上两种屏障组合而来：</p><ul><li><p><strong>LoadLoad Barriers</strong>：<code>Load1 | LoadLoad | Load2</code></p><p><code>Load2</code>及后续读取的操作必须等待<code>Load1</code>读取数据完成。</p></li><li><p><strong>StoreStore Barriers</strong>：<code>Store1 | StoreStore | Store2</code></p><p><code>Store2</code>及后续写入的操作必须等待<code>Store1</code>写入完成，保证<code>Store1</code>写入结果对其他线程可见。</p></li><li><p><strong>LoadStore Barriers</strong>：<code>Load1 | LoadStore | Store2</code></p><p><code>Store2</code>及后续写入的操作必须等待<code>Load1</code>读取数据完成。</p></li><li><p><strong>StoreLoad Barriers</strong>：<code>Store1 | StoreLoad | Load2</code></p><p><code>Load2</code>及后续读取的操作必须等待<code>Store1</code>写入完成，保证<code>Store1</code>写入结果对其他线程可见。该屏障会使屏障前所有的内存指令执行完毕之后才会允许屏障之后的操作执行，且会将屏障前操作的结果全部从高速缓存区刷新到主存中。</p></li></ul><p><code>StoreLoad Barriers</code>是一个全能屏障，兼具其他3种屏障的功能，也是大多数处理器所支持的一种屏障。使用该屏障需要高昂的开销，因为这个屏障前所有操作的结果都要对屏障后可见，即会将屏障前操作的结果全部刷新到主存，操作结果对屏障后的相关操作可见。</p><p><code>Java</code>代码中一般不会主动使用内存屏障，主要用到内存屏障的地方在三个关键字上，即<code>synchronized</code>、<code>volatile</code>、<code>final</code>(后续会单独介绍这三个关键字)。当然实在要自己加也是有办法的，那就是<code>Java</code>的<code>Unsafe</code>类，这个类提供了一些和硬件交互的一些本地方法，这里不再展开，需要了解可<code>Google</code>。</p><h1 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><code>happens-before</code>是<code>JMM</code>最核心的概念，理解<code>happens-before</code>也是理解<code>JMM</code>的核心。那么什么是<code>happens-before</code>呢，<code>happens-before</code>的概念最初由<code>Leslie Lamport</code>在其一篇影响深远的论文《Time，Clocks and the Ordering of Events in a Distributed System》中提出的，<code>JSR-133</code>中使用<code>happens-before</code>来阐述操作之间的内存可见性，如果一个操作的执行结果需要对另一个操作可见，那么这两个这两个操作就必须存在<code>happens-before</code>的关系，两个操作可以在同一个线程内，也可以在不同线程之间，其次，<code>happens-before</code>仅仅是要求前一个操作的结果对后一个操作可见，并不是说前一个操作一定要先于后一个操作发生。</p><p><code>JMM</code>在设计时关键需要考虑两点：</p><ul><li><p>程序员对内存模型的使用。</p><p>程序员希望内存模型是易于理解、易于编程的，程序员希望基于一个强内存模型来编写代码。</p></li><li><p>编译器和处理器对内存模型的实现。</p><p>编译器和处理器是希望内存模型对它们的束缚越少越好，这样它们就可以尽可能的优化来提升效率，编译器和处理器希望实现一个弱内存模型。</p></li></ul><p><code>JMM</code>将重排序分为两种情况：</p><ul><li><p>会改变程序运行结果的重排序。</p><p>对于这类重排序，<code>JMM</code>要求编译器和处理器必须禁止重排序。</p></li><li><p>不会改变程序运行结果的重排序。</p><p>对于这类重排序，<code>JMM</code>则不做要求(即<code>JMM</code>允许此类重排序)。</p></li></ul><p>下面是<code>JMM</code>设计示意图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/happens-before%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="JMM设计示意图"></p><p>不难理解<code>JMM</code>在设计时关键需要考虑两点是互相矛盾的，那么<code>JMM</code>是如何平衡这两点的呢。从图中可以看到<code>JMM</code>为程序员提供了易于理解的<code>happens-before</code>规则，同时也为程序员提供了足够的内存可见性保证。同时，<code>JMM</code>也尽可能少的对编译器和处理器进行限制。</p><p><code>JMM</code>其实一直都是在遵循一个原则：只要不改变程序的执行结果(指单线程程序和正确同步的多线程程序)，编译器和处理器怎么优化都可以(其实<code>as-if-serial</code>语义也是这样的)。例如，如果编译器经过细致的分析后，认定一个锁只会被单个 线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个volatile变 量只会被单个线程访问，那么编译器可以把这个volatile变量当作一个普通变量来对待。这些 优化既不会改变程序的执行结果，又能提高程序的执行效率。</p><p><code>JSR-133</code>对<code>happens-before</code>有如下定义：</p><ul><li>如果一个操作<code>happens-before</code>另一个操作，那么第一个操作的执行结果将对第二个操作 可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在<code>happens-before</code>关系，并不意味着<code>Java</code>平台的具体实现必须要按照<code>happens-before</code>关系指定的顺序来执行。如果重排序之后的执行结果，与按<code>happens-before</code>关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li></ul><p>上面两点同样还是对应于程序员和处理器、编译器双方的矛盾作出的平衡。第一点是对程序员的保证，从程序员的角度来说，可以这样理解<code>happens-before</code>关系：如果<code>A happens-before B</code>，那么<code>Java</code>内存模型将向程序员保证——A操作的结果将对B可见， 且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！而第二点则是<code>JMM</code>对处理器、编译器的让步，<code>JMM</code>其实是在遵循一个基本原则：只要不改变程序的执行结果(指的是单线程程序和正确同步的多线程程序)， 编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重 排序并不关心，程序员关心的是程序执行时的语义不能被改变(即执行结果不能被改变)。因 此，<code>happens-before</code>关系本质上和<code>as-if-serial</code>语义是一回事。</p><h2 id="对比as-if-serial"><a href="#对比as-if-serial" class="headerlink" title="对比as-if-serial"></a>对比as-if-serial</h2><p>对比<code>happens-before</code>和<code>as-if-serial</code>：</p><ul><li><code>as-if-serial</code>语义保证单线程内程序的执行结果不被改变，<code>happens-before</code>关系保证正确同步的多线程程序的执行结果不被改变。</li><li><code>as-if-serial</code>语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺 序来执行的。<code>happens-before</code>关系给编写正确同步的多线程程序的程序员创造了一个幻境：正 确同步的多线程程序是按<code>happens-before</code>指定的顺序来执行的。</li><li><code>as-if-serial</code>语义和<code>happens-before</code>这么做的目的，都是为了在不改变程序执行结果的前提 下，尽可能地提高程序执行的并行度。</li></ul><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><p>在<code>JSR-133</code>中定义了如下规则：</p><ul><li>程序顺序规则：一个线程中的每个操作，<code>happens-before</code>于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，<code>happens-before</code>于随后对这个锁的加锁。</li><li><code>volatile</code>变量规则：对一个<code>volatile</code>域的写，<code>happens-before</code>于任意后续对这个<code>volatile</code>域的读。 </li><li>传递性：如果<code>A happens-before B</code>，且<code>B happens-before C</code>，那么<code>A happens-before C</code>。 </li><li><code>start()</code>规则：如果线程A执行操作<code>ThreadB.start()</code>(启动线程B)，那么A线程的 <code>ThreadB.start()</code>操作<code>happens-before</code>于线程B中的任意操作。</li><li><code>join()</code>规则：如果线程A执行操作<code>ThreadB.join()</code>并成功返回，那么线程B中的任意操作 <code>happens-before</code>于线程A从<code>ThreadB.join()</code>操作成功返回。</li></ul><blockquote><p>参考自《Java并发编程的艺术》</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrecy </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线程的生命周期</title>
      <link href="/2020/04/06/java-2020-04-06-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2020/04/06/java-2020-04-06-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>前面介绍了线程相关的一些基本概念，也说了一个线程的创建以及销毁，那么一个线程应该是有生命周期的。这里就来看一下，一个线程一生可能会经历哪些阶段。</p><h1 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h1><p>线程的一生可能会经过以下6种状态：</p><ul><li><p><code>NEW</code></p><p>初始化状态，线程被创建，但是还没有调用<code>start</code>方法。</p><p>线程的创建过程其实在前面<a href="[https://blogs.felixu.top/2020/04/04/java-2020-04-04-%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/](https://blogs.felixu.top/2020/04/04/java-2020-04-04-从线程到并发编程/">从线程说起并发问题</a>)介绍线程创建的时候已经说过了，这里就不再上代码了，简单说一下使用线程的三种方式：</p><ul><li>实现<code>Runnable</code>接口，重写<code>run</code>方法。</li><li>继承<code>Thread</code>类，重写<code>run</code>方法。</li><li>实现<code>Callable</code>接口，重写<code>call</code>方法，实现带返回值的线程。</li></ul></li><li><p><code>RUNNABLE</code></p><p>运行中状态，其实这里应该是包含两种状态的，一种是就绪状态(即线程调用了<code>start</code>方法，但是不一定会立马运行，还需要等待系统<code>OS</code>的调度)，另一种是运行状态(即正在执行中)。</p></li><li><p><code>BLOCKED</code></p><p>阻塞状态，线程进入等待状态。而阻塞又分为多种情况。</p><ul><li>等待阻塞：线程执行<code>wait</code>方法，<code>JVM</code>将当前线程加入等待队列。</li><li>同步阻塞：与其他线程竞争同步锁时，由于锁已被其他线程获取，进而被<code>JVM</code>加入同步队列。</li><li>其他阻塞：<code>Thread.sleep()</code>、<code>join</code>、<code>IO</code>等操作时，<code>JVM</code>会阻塞直至上述操作结束才会恢复线程。</li></ul></li><li><p><code>WAITTING</code></p><p>等待状态，线程进入等待，需要被唤醒。</p></li><li><p><code>TIME_WAITTING</code></p><p>等待状态，超时以后自动返回。</p></li><li><p><code>TERMINATED</code></p><p>终止状态，线程执行完毕退出。</p></li></ul><h1 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a>线程状态的转换</h1><p>线程的一生可能会经过以上六个阶段，那么它们之间又是怎么转换的呢，这里贴上流程转换的图：</p><p><img src="https://felixu-blog.oss-cn-hangzhou.aliyuncs.com/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt="线程状态转换"></p><p>在图上可以看到一些操作，等到后面再慢慢介绍这些都是干嘛用的。</p><p>我们也可以通过以下代码来演示一下线程的相关状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStatus</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"time-waiting"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ThreadStatus.class) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ThreadStatus.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"waiting"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Block(),<span class="string">"Block-01"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Block(),<span class="string">"Block-02"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Block.class)&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码运行起来之后，我们打开控制台，执行<code>jps</code>命令，这个命令可以获得相应<code>Java</code>进程的<code>PID</code>。</p><p>在执行<code>jstack PID</code>(<code>PID</code>是我们上一步拿到的)可以得到下面的<code>dump</code>信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">. . . . . .省略部分信息</span><br><span class="line">"Block-02" #16 prio=5 os_prio=31 tid=0x00007ffe1683e000 nid=0xa303 waiting for monitor entry [0x0000700006b83000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at top.felixu.chapter1.lifecycle.ThreadStatus$Block.run(ThreadStatus.java:44)</span><br><span class="line">        - waiting to lock &lt;0x000000076b0cdb00&gt; (a java.lang.Class for top.felixu.chapter1.lifecycle.ThreadStatus$Block)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"Block-01" #14 prio=5 os_prio=31 tid=0x00007ffe1683a000 nid=0xa503 waiting on condition [0x0000700006a80000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at top.felixu.chapter1.lifecycle.ThreadStatus$Block.run(ThreadStatus.java:44)</span><br><span class="line">        - locked &lt;0x000000076b0cdb00&gt; (a java.lang.Class for top.felixu.chapter1.lifecycle.ThreadStatus$Block)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"waiting" #12 prio=5 os_prio=31 tid=0x00007ffe13089000 nid=0xa603 in Object.wait() [0x000070000697d000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">        at java.lang.Object.wait(Native Method)</span><br><span class="line">        - waiting on &lt;0x000000076aeed260&gt; (a java.lang.Class for top.felixu.chapter1.lifecycle.ThreadStatus)</span><br><span class="line">        at java.lang.Object.wait(Object.java:502)</span><br><span class="line">        at top.felixu.chapter1.lifecycle.ThreadStatus.lambda$main$1(ThreadStatus.java:26)</span><br><span class="line">        - locked &lt;0x000000076aeed260&gt; (a java.lang.Class for top.felixu.chapter1.lifecycle.ThreadStatus)</span><br><span class="line">        at top.felixu.chapter1.lifecycle.ThreadStatus$$Lambda$2/668386784.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"time-waiting" #11 prio=5 os_prio=31 tid=0x00007ffe16839000 nid=0xa803 waiting on condition [0x000070000687a000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at top.felixu.chapter1.lifecycle.ThreadStatus.lambda$main$0(ThreadStatus.java:15)</span><br><span class="line">        at top.felixu.chapter1.lifecycle.ThreadStatus$$Lambda$1/764977973.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">. . . . . .省略部分信息</span><br></pre></td></tr></table></figure><p>从上面的<code>dump</code>可以看到线程的大部分状态了，有些状态没法从<code>dump</code>的信息中看出来。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>不知道写点啥，拉倒吧，没有结语。</p><blockquote><p>参考自《Java并发编程的艺术》</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从线程到并发编程</title>
      <link href="/2020/04/04/java-2020-04-04-%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/04/04/java-2020-04-04-%E4%BB%8E%E7%BA%BF%E7%A8%8B%E5%88%B0%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h1><p>说起线程，还是得从进程说起。那么进程是什么呢？现代操作系统在运行一个程序时，会为其创建一个进程。比如你电脑上打开个<code>QQ</code>或者是启动一个<code>Java</code>程序，操作系统都会为其创建一个进程。而线程是操作系统的最小调度单元，一个进程中可以有多个线程。<code>OS</code>调度会让多个线程之间高速切换，让我们以为是多个线程在同时执行。</p><h1 id="线程的创建与销毁"><a href="#线程的创建与销毁" class="headerlink" title="线程的创建与销毁"></a>线程的创建与销毁</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>那么怎么去创建一个线程呢。在<code>Java</code>中我们有且仅有一种(至于为啥说只有一种，而网上说有三种，那是因为其他两种并非创建线程，而是创建了线程的执行单元，最后还是交由<code>Thread</code>去执行)方式来创建线程，那就是<code>new Thread()</code>，但是我们却可以有以下三种方式来使用：</p><ol><li><p>继承<code>Thread</code>类，重写<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"extends thread run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo1 thread1 = <span class="keyword">new</span> ThreadDemo1();</span><br><span class="line">        ThreadDemo1 thread2 = <span class="keyword">new</span> ThreadDemo1();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Runnable</code>接口，重写<code>run</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" implements runnable run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo2(), <span class="string">"thread1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadDemo2(), <span class="string">"thread2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现<code>Callable</code>接口，重写<code>call</code>方法，实现带返回值的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        ThreadDemo3 thread = <span class="keyword">new</span> ThreadDemo3();</span><br><span class="line">        Future&lt;String&gt; future = executorService.submit(thread);</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" implements callable"</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><ol><li><p><code>interrupt</code>中断标志</p><p>前面看完了如何创建一个线程，那么又怎么去终止一个线程呢。以前的<code>Thread</code>类中有个<code>stop</code>方法可以用来终止线程，而现在已经被标记过期了，其实也不建议使用<code>stop</code>方法来终止线程，为什么呢！因为我想用过<code>Linux</code>系统的都知道<code>kill -9</code>吧，<code>stop</code>方法与其类似，<code>stop</code>方法会强制杀死线程，而不管线程中的任务是否执行完毕，那么我们如何更加优雅的去终止一个线程呢。</p><p>这里<code>Thread</code>类为我们提供了一个<code>interrupt</code>方法。</p><p>当我们需要终止一个线程，可以调用它的<code>interrupt</code>方法，相当于告诉这个线程你可以终止了，而不是暴力的杀死该线程，线程会自行中断，我们可以使用<code>isInterrupted</code>方法来判断线程是否已经终止了，我们可以用下面的代码来加以验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"result: "</span> + i);</span><br><span class="line">        &#125;, <span class="string">"interrupt-test"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>interrupt</code>方法无法终止线程，那么这个线程将会是死循环，而无法结束。这里使用<code>interrupt</code>以一种更加安全中断线程。</p></li><li><p><code>volatile</code>共享变量作为中断标志</p><p>这里先不介绍<code>volatile</code>的内存语义以及原理，它可以解决共享变量的内存可见性问题，使其他线程可以及时看到被<code>volatile</code>变量修饰的共享变量的变更，所以我们也可以使用<code>volatile</code>来达到中断线程的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> i = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;, <span class="string">"volatile-demo"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        System.out.println(<span class="string">"volatile-demo is start"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如上面示例中的代码，我们可以控制在特定的地方，改变共享变量，来达到让线程退出。</p></li></ol><h2 id="线程复位"><a href="#线程复位" class="headerlink" title="线程复位"></a>线程复位</h2><ul><li><p><code>interrupted</code></p><p>前面说了使用<code>interrupt</code>可以告诉线程可以中断了，线程同时也提供了另外一个方法即<code>Thread.interrupted()</code>可以将已经设置过中断标志的线程进行复位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> isInterrupted = Thread.currentThread().isInterrupted();</span><br><span class="line">                <span class="keyword">if</span>(isInterrupted)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"before: "</span> + isInterrupted);</span><br><span class="line">                    Thread.interrupted(); <span class="comment">// 对线程进行复位，中断标识为false</span></span><br><span class="line">                    System.out.println(<span class="string">"after: "</span> + Thread.currentThread().isInterrupted());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"InterruptDemo"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        thread.interrupt(); <span class="comment">// 设置中断标识为true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: true</span><br><span class="line">after: false</span><br></pre></td></tr></table></figure><p>通过<code>demo</code>可以看到线程确实是先被设置了中断标识，后又被复位。</p></li><li><p>异常复位</p><p>除了使用<code>interupted</code>来设置中断复位，还有一种情况，就是对抛出<code>InterruptedException</code>异常的方法，在 <code>InterruptedExceptio</code>抛出之前，<code>JVM</code>会先把线程的中断标识位清除，然后才会抛出 <code>InterruptedException</code>，这个时候如果调用<code>isInterrupted</code>方法，将会返回<code>false</code>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// 抛出InterruptedException会将复位标识设置为false</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"InterruptDemo"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        thread.interrupt(); <span class="comment">// 设置中断标志为true</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(thread.isInterrupted()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at java.lang.Thread.sleep(Native Method)</span><br><span class="line">at top.felixu.chapter1.lifecycle.InterruptDemo.lambda$main$0(InterruptDemo.java:48)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>通过例子可以看到，在抛出异常之后，<code>isInterrupted</code>确实是又变成了<code>false</code>。</p></li></ul><h1 id="为什么要并发编程"><a href="#为什么要并发编程" class="headerlink" title="为什么要并发编程"></a>为什么要并发编程</h1><p>单线程有时候也可以解决问题啊，那么我们为什么还要并发编程呢，很大程度上是因为更好的利用<code>CPU</code>资源，提升我们系统的性能。根据摩尔定律(当价格不变时，集成电路上可容纳的元器件的数目，约每隔<code>18-24</code>个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔<code>18-24</code>个月翻一倍以上。这一定律揭示了信息技术进步的速度。)推算，不久就会有超强的计算能力，然而，事情并未像预料的那样发展。<code>2004</code>年，<code>Intel</code>宣布<code>4GHz</code>芯片的计划推迟到<code>2005</code>年，然后在<code>2004</code>年秋季，<code>Intel</code>宣布彻底取消<code>4GHz</code>的计划。现在虽然有<code>4GHz</code>的芯片但频率极限已逼近，而且近<code>10</code>年停留在<code>4GHz</code>，也就是摩尔定律应该是失效了。既然单核<code>CPU</code>的计算能力短期无法提升了，而我们伟大的硬件科学家们可不会承认自己的理论是错的，那既然一个<code>CPU</code>搞不定了，那么就多个嘛，多核<code>CPU</code>在此时应运而生。单线程毕竟只可能跑在一个核心上，浪费了<code>CPU</code>的资源，从而催生了并发编程，并发编程是为了发挥出多核<code>CPU</code>的计算能力，提升性能。</p><blockquote><p>顶级计算机科学家<code>Donald Ervin Knuth</code>如此评价这种情况：在我看来，这种现象(并发)或多或少是由于硬件设计者无计可施了导致的，他们将摩尔定律的责任推给了软件开发者。</p></blockquote><p>并发编程总结起来说大致有以下优点：</p><ul><li>充分利用<code>CPU</code>，提高计算能力。</li><li><p>方便对业务的拆分。比如一个购物流程，我们可以拆分成下单，减库存等，利用多线程来加快响应。</p></li><li><p>对于需要阻塞的场景，可以异步处理，来减少阻塞。</p></li><li>对于执行性能，可以通过多线程并行计算。</li></ul><h1 id="并发编程有哪些问题"><a href="#并发编程有哪些问题" class="headerlink" title="并发编程有哪些问题"></a>并发编程有哪些问题</h1><p>看起来好像多线程确实很好，那么我们就可以尽量多的去开线程了嘛。也并不是这样的，多线程的性能也受多方面因素所影响：</p><ul><li><p>时间片的切换</p><p>时间片是<code>CPU</code>分配给线程执行的时间，即便是单核<code>CPU</code>也是可以通过时间片的切换使多个线程切换执行，让我们觉得是多个线程在同时执行，因为时间片的切换是非常快的，我们感觉不到的。每次切换线程是需要时间的，而且切换的时候需要保存当前线程的状态，以便切换回来的时候可以继续执行。所以当线程较多的时候，切换时间片所带来的消耗也同样可观。那么有没有什么姿势可以解决这个问题呢，是有的：</p><ul><li>无锁并发编程：多线程在竞争锁时会引起上下文的切换，可以使用对数据<code>Hash</code>取模分段的思想来避免使用锁。</li><li><code>CAS</code>算法：可以使用<code>Atomic</code>包中相关原子操作，来避免使用锁。</li><li>使用最少线程：根据业务需求创建线程数，过多的创建线程会造成线程闲置和资源浪费。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul></li><li><p>死锁</p><p>为了保证多线程的正确性，很多时候，我们都会使用锁，它是一个很好用的工具，然而在一些时候，不正确的姿势会造成死锁问题，进而引发系统不可用。下面我们就来看一个死锁案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> DeadLockDemo().deadLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deadLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">        Thread one = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread-one"</span>);</span><br><span class="line"></span><br><span class="line">        Thread two = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"thread-two"</span>);</span><br><span class="line"></span><br><span class="line">        one.start();</span><br><span class="line">        two.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后便会发现程序无法终止了，那么究竟发生了什么呢？我们通过<code>jps</code>命令来查看一下当前<code>Java</code>的<code>PID</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps</span></span><br><span class="line">1483 DeadLockDemo</span><br></pre></td></tr></table></figure><p>可以看到当前的程序<code>PID</code>为<code>1483</code>(每个人的都不一样，得自己执行哦)，接下来我们使用<code>jstack</code>命令<code>dump</code>出当前程序的线程信息，看一下究竟发生了什么。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> jstack 1483</span><br><span class="line">. . . . . .省略部分信息</span><br><span class="line">"thread-two" #12 prio=5 os_prio=31 tid=0x00007fbba9956800 nid=0x5603 waiting for monitor entry [0x0000700011058000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo.lambda$deadLock$1(DeadLockDemo.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000076ada81b8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ada81c8&gt; (a java.lang.Object)</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo$$Lambda$2/381259350.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">"thread-one" #11 prio=5 os_prio=31 tid=0x00007fbba8033800 nid=0xa803 waiting for monitor entry [0x0000700010f55000]</span><br><span class="line">   java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo.lambda$deadLock$0(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ada81c8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ada81b8&gt; (a java.lang.Object)</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo$$Lambda$1/1607521710.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">. . . . . .省略部分信息</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">"thread-two":</span><br><span class="line">  waiting to lock monitor 0x00007fbba9006eb8 (object 0x000000076ada81b8, a java.lang.Object),</span><br><span class="line">  which is held by "thread-one"</span><br><span class="line">"thread-one":</span><br><span class="line">  waiting to lock monitor 0x00007fbba90082a8 (object 0x000000076ada81c8, a java.lang.Object),</span><br><span class="line">  which is held by "thread-two"</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">"thread-two":</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo.lambda$deadLock$1(DeadLockDemo.java:32)</span><br><span class="line">        - waiting to lock &lt;0x000000076ada81b8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ada81c8&gt; (a java.lang.Object)</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo$$Lambda$2/381259350.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">"thread-one":</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo.lambda$deadLock$0(DeadLockDemo.java:24)</span><br><span class="line">        - waiting to lock &lt;0x000000076ada81c8&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;0x000000076ada81b8&gt; (a java.lang.Object)</span><br><span class="line">        at top.felixu.section1.deadlock.DeadLockDemo$$Lambda$1/1607521710.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>从上面来看，两个线程都是阻塞状态，都在等待别的线程释放锁，但是永远都等不到，从而形成了死锁。那么平常开发过程中尽量按以下操作来避免不必要的死锁(当然有时候不注意还是会莫名死锁，得<code>dump</code>信息加以分析才能找出问题的)：</p><ul><li>避免一个线程同时获取多个锁。</li><li>尽量避免一个线程在锁内同时获取多个资源，尽量保证每个锁内只占有一个资源。</li><li>尝试使用定时锁，使用<code>lock.tryLock(timeout)</code>来替代使用内部锁机制。</li><li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li></ul></li><li><p>软件和硬件资源的限制</p><p>程序跑在服务器上，必然受到服务器等方面的限制。</p><ul><li>硬件资源限制：一般指磁盘读写速度、带宽、<code>CPU</code>性能等方面</li><li>软件资源限制：一般指数据库连接数、<code>Socket</code>连接数等方面</li></ul></li></ul><p>所以，如何合理的使用线程需要我们在实践中具体去分析。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>并发编程一直是个难点，也是在面试中不可避免被问到的知识点，后面会更多讨论其他方面的知识点，也需要更多的动手实践，才能体会其中的一些深层意义。</p><blockquote><p>参考自《Java并发编程的艺术》</p></blockquote>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Concurrency </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8新时间API</title>
      <link href="/2020/04/03/java-2020-04-03-Java8%E6%96%B0%E6%97%B6%E9%97%B4API/"/>
      <url>/2020/04/03/java-2020-04-03-Java8%E6%96%B0%E6%97%B6%E9%97%B4API/</url>
      <content type="html"><![CDATA[<p><code>Java8</code>日期/时间<code>API</code>是<code>JSR-310(Java Specification Requests)</code>的实现，它的实现目标是克服旧的日期时间实现中所有的缺陷，利用它可以更加方便我们去处理时间和日期的计算等问题。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>新的日期/时间<code>API</code>它遵循以下的设计原则：</p><ul><li><strong>不变性</strong>：在新的日期/时间<code>API</code>中，所有的类都被设计成不可变的，这在多线程环境下也是没有问题的。</li><li><strong>关注点分离</strong>：在<code>Java8</code>中，相比于之前旧的时间和日历类，较大的改变是将人可读的日期时间和机器时间<code>(unix timestamp)</code>明确分离，为日期<code>(Date)</code>、时间<code>(Time)</code>、日期时间<code>(DateTime)</code>、时间戳<code>(unix timestamp)</code>以及时区定义了不同的类。</li><li><strong>清晰</strong>：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用<code>now()</code>方法，在所有的类中都定义了<code>format()</code>和<code>parse()</code>方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。</li><li><strong>实用操作</strong>：所有新的日期/时间<code>API</code>类都实现了一系列方法用以完成通用的任务，如：加、减、 格式化、解析、从日期/时间中提取单独部分，等等。</li><li><strong>可扩展性</strong>： 新的日期/时间<code>API</code>是工作在<code>ISO-8601</code>日历系统上的，但我们也可以将其应用在非<code>ISO</code>的日历上。</li></ul><h1 id="time-包"><a href="#time-包" class="headerlink" title="time 包"></a>time 包</h1><p><code>java.time</code>包中的是类是不可变且线程安全的，下面是一些比较常用的类： </p><ul><li><code>Instant</code>：表示时间戳。</li><li><code>LocalDate</code>：不包含具体时间点的日期。</li><li><code>LocalTime</code>：不包含日期的时间点。</li><li><code>LocalDateTime</code>：具体的日期时间点，不带时区。</li><li><code>ZonedDateTime</code>：包含时区的完整的日期时间点，偏移量是以<code>UTC</code>/格林威治时间为基准的。 </li></ul><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>对于这些类，它们都有以下一些方法：</p><ul><li><code>of</code>：静态工厂方法。</li><li><code>parse</code>：静态工厂方法，关注于解析。</li><li><code>get</code>：获取某些东西的值。</li><li><code>is</code>：检查某些东西的是否是true。</li><li><code>with</code>：不可变的setter等价物。</li><li><code>plus</code>：加一些量到某个对象。</li><li><code>minus</code>：从某个对象减去一些量。</li><li><code>to</code>：转换到另一个类型。</li><li><code>at</code>：把这个对象与另一个对象组合起来。</li></ul><p>下面我们就来看看他们具体都是怎么用的。</p><h2 id="计算日期-时间"><a href="#计算日期-时间" class="headerlink" title="计算日期/时间"></a>计算日期/时间</h2><h3 id="获取当前时间-日期"><a href="#获取当前时间-日期" class="headerlink" title="获取当前时间/日期"></a>获取当前时间/日期</h3><p>以前有<code>Date</code>类可以获取当前时间，有<code>Calendar</code>类来做日历相关操作。而在<code>Java8</code>中，提供了多个类来获取当前的日期、时间、时间戳等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        System.out.println(LocalDate.now());</span><br><span class="line">        <span class="comment">// 获取当前时间点</span></span><br><span class="line">        System.out.println(LocalTime.now());</span><br><span class="line">        <span class="comment">// 获取当前时间点去掉纳秒</span></span><br><span class="line">        System.out.println(LocalTime.now().withNano(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 获取当前的日期时间</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">// 获取当前年</span></span><br><span class="line">        System.out.println(LocalDate.now().getYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2017-09-04</span><br><span class="line">22:03:49.502</span><br><span class="line">22:03:49</span><br><span class="line">2017-09-04T22:03:49.502</span><br><span class="line">2017</span><br></pre></td></tr></table></figure><p>不要在意这个鸡毛年份，文章写于<code>N</code>久前，最近改改重新发出来的。</p><h3 id="判断两个日期是否相等"><a href="#判断两个日期是否相等" class="headerlink" title="判断两个日期是否相等"></a>判断两个日期是否相等</h3><p>在<code>Java8</code>的众多类中，它们都重写了<code>toString()</code>方法。所以对于日期是否相同的判断，我们可以直接使用它的<code>equals()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        <span class="comment">// 构建2017-09-03</span></span><br><span class="line">        LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 判断是否相等</span></span><br><span class="line">        System.out.println(today.equals(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="判断一个日期是否在另一个日期之前"><a href="#判断一个日期是否在另一个日期之前" class="headerlink" title="判断一个日期是否在另一个日期之前"></a>判断一个日期是否在另一个日期之前</h3><p>有时候可能会有这样的需求，需要判断一个日期在另一个日期的前面还是后面，这时候就会用到<code>isBefore()</code>和<code>isAfter()</code>方法，这样就可以方便的作出判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建2017-09-04</span></span><br><span class="line">        LocalDate d1 = LocalDate.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 构建2017-09-03</span></span><br><span class="line">        LocalDate d2 = LocalDate.of(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 判断d1是否在d2后面</span></span><br><span class="line">        System.out.println(d1.isAfter(d2));</span><br><span class="line">        <span class="comment">// 判断d1是否在d2前面</span></span><br><span class="line">        System.out.println(d1.isBefore(d2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>可以看到我们直接可以使用<code>isBefore()</code>和<code>isAfter()</code>来判断两个日期谁前谁后了，而不需要向之前使用<code>Calendar</code>来进行麻烦的操作了。</p><h3 id="检查重复日期"><a href="#检查重复日期" class="headerlink" title="检查重复日期"></a>检查重复日期</h3><p>对于一些特定的日期，比如生日、纪念日等，我们可以轻易来判断某一日期是不是我们需要的特定日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate dateOfBirth = LocalDate.of(<span class="number">1992</span>, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">        MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">        MonthDay currentMonthDay = MonthDay.from(LocalDate.now());</span><br><span class="line">        <span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Happy Birthday !"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry, today is not your birthday！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy Birthday !</span><br></pre></td></tr></table></figure><h3 id="判断某个日期是不是周几"><a href="#判断某个日期是不是周几" class="headerlink" title="判断某个日期是不是周几"></a>判断某个日期是不是周几</h3><p>同样，我们可以很方便的来判断某天是周几。<code>DayOfWeek</code>构建的是周几，然后使用<code>from()</code>方法，来构建某一日期为周几，这样我们就可以轻松判断出某一日期是周几，而不必向以前一样麻烦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DayOfWeek dayOfWeek = DayOfWeek.of(<span class="number">2</span>);</span><br><span class="line">        DayOfWeek from = DayOfWeek.from(LocalDate.now());</span><br><span class="line">        System.out.println(from.equals(dayOfWeek));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="延迟或者推前时间"><a href="#延迟或者推前时间" class="headerlink" title="延迟或者推前时间"></a>延迟或者推前时间</h3><p>有时候我们可能会需要用到一些日期计算，比如，昨天，前天，明天，一周前，一年前等。在Java8中可以轻松实现，因为这些类中已经提供了相关方法。<code>plus</code>开头的表示往后算，<code>minus</code>表示往前算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        System.out.println(today);</span><br><span class="line">        <span class="comment">// 推前一天</span></span><br><span class="line">        System.out.println(today.minusDays(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 延后一天</span></span><br><span class="line">        System.out.println(today.plusDays(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-09-04</span><br><span class="line">2017-09-03</span><br><span class="line">2017-09-05</span><br></pre></td></tr></table></figure><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p><code>Java8</code>提供了时钟类，利用时钟类可以实现和<code>System.currentTimeMillis()</code>一样的功能，还能够获取当前时区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        System.out.println(Clock.systemUTC().millis());</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 获取当前系统默认时区</span></span><br><span class="line">        System.out.println(Clock.systemDefaultZone().getZone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1504478880531</span><br><span class="line">1504478880531</span><br><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure><h3 id="检查闰年"><a href="#检查闰年" class="headerlink" title="检查闰年"></a>检查闰年</h3><p>可以使用<code>isLeapYear()</code>方法直接判断是否为闰年，而不用我们再自己去计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>).isLeapYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="带时区计算"><a href="#带时区计算" class="headerlink" title="带时区计算"></a>带时区计算</h3><p><code>Java 8</code>不仅将日期和时间进行了分离，同时还有时区。现在已经有好几组与时区相关的类了，比如<code>ZonId</code>代表的是某个特定的时区，而<code>ZonedDateTime</code>代表的是带时区的时间。它等同于<code>Java 8</code>以前的<code>GregorianCalendar</code>类。使用这个类，你可以将本地时间转换成另一个时区中的对应时间。用<code>ZoneOffset</code>类来代表某个时区，比如印度是<code>GMT</code>或者<code>UTC5：30</code>，你可以使用它的静态方法<code>ZoneOffset.of()</code>方法来获取对应的时区。只要获取到了这个偏移量，你就可以拿<code>LocalDateTime</code>和这个偏移量创建出一个<code>OffsetDateTime</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 设置时区</span></span><br><span class="line">        ZonedDateTime zonedDateTime = ZonedDateTime.of(now, ZoneId.of(<span class="string">"Australia/Darwin"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个时间</span></span><br><span class="line">        LocalDateTime datetime = LocalDateTime.of(<span class="number">2017</span>, Month.SEPTEMBER, <span class="number">5</span>, <span class="number">7</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 设置偏移量</span></span><br><span class="line">        ZoneOffset offset = ZoneOffset.of(<span class="string">"+05:30"</span>);</span><br><span class="line">        <span class="comment">// 构建带偏移量的日期和时间</span></span><br><span class="line">        OffsetDateTime date = OffsetDateTime.of(datetime, offset);</span><br><span class="line">        System.out.println(<span class="string">"Date and Time with timezone offset in Java : "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Current date and time in a particular timezone : 2017-09-05T07:50:43.187+09:30[Australia/Darwin]</span><br><span class="line">Date and Time with timezone offset in Java : 2017-09-05T07:50+05:30</span><br></pre></td></tr></table></figure><p><code>OffSetDateTime</code>主要是给机器来理解的，如果是给人看的，可以使用<code>ZoneDateTime</code>类。</p><h3 id="固定日期"><a href="#固定日期" class="headerlink" title="固定日期"></a>固定日期</h3><p>在前面我们用过一个<code>MonthDay</code>的类，用来构建特定的几月几日。这里用到了另一个<code>YearMonth</code>，它表示某年某月，我们可以它来知道某年某月有多少天，使用<code>YearMonth</code>的<code>lengthOfMonth()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前年月</span></span><br><span class="line">        YearMonth current = YearMonth.now();</span><br><span class="line">        System.out.println(current);</span><br><span class="line">        <span class="comment">// 获取这个月有多少天</span></span><br><span class="line">        System.out.println(current.lengthOfMonth());</span><br><span class="line">        <span class="comment">// 构建一个固定日期</span></span><br><span class="line">        YearMonth expire = YearMonth.of(<span class="number">2017</span>, Month.NOVEMBER);</span><br><span class="line">        System.out.println(expire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2017-09</span><br><span class="line">30</span><br><span class="line">2017-11</span><br></pre></td></tr></table></figure><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String dayAfterTomorrow = <span class="string">"20170905"</span>;</span><br><span class="line">        LocalDate formatted = LocalDate.parse(dayAfterTomorrow,</span><br><span class="line">                DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">        System.out.printf(<span class="string">"Date generated from String %s is %s %n"</span>, dayAfterTomorrow, formatted);</span><br><span class="line"></span><br><span class="line">        String goodFriday = <span class="string">"Sep 05 2017"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);</span><br><span class="line">            LocalDate holiday = LocalDate.parse(goodFriday, formatter);</span><br><span class="line">            System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalDateTime arrivalDate = LocalDateTime.now();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy hh:mm a"</span>);</span><br><span class="line">            String landing = arrivalDate.format(format);</span><br><span class="line">            System.out.printf(<span class="string">"Arriving at : %s %n"</span>, landing);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date generated from String 20170905 is 2017-09-05 </span><br><span class="line">Successfully parsed String Sep 05 2018, date is 2017-09-05</span><br><span class="line">Arriving at : Sep 06 2017 07:47 AM</span><br></pre></td></tr></table></figure><h2 id="计算时间间隔"><a href="#计算时间间隔" class="headerlink" title="计算时间间隔"></a>计算时间间隔</h2><p><code>Java8</code>为我们提供了三个类来方便计算时间间隔，分别是</p><ul><li><code>Duration</code>：计算秒、纳秒。</li><li><code>ChronoUnit</code>：计算天、时、分、秒。</li><li><code>Period</code>：计算年、月、日。</li></ul><h3 id="秒、纳秒"><a href="#秒、纳秒" class="headerlink" title="秒、纳秒"></a>秒、纳秒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        Instant i1 = Instant.now();</span><br><span class="line">        <span class="comment">// 当前时间推后10s</span></span><br><span class="line">        Instant i2 = i1.plusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 获取时间差</span></span><br><span class="line">        Duration between = Duration.between(i1, i2);</span><br><span class="line">        <span class="comment">// 获取时间差的毫秒值</span></span><br><span class="line">        System.out.println(between.toMillis());</span><br><span class="line">        <span class="comment">// 获取时间差的纳秒值</span></span><br><span class="line">        System.out.println(between.toNanos());</span><br><span class="line">        <span class="comment">// 获取时间差的天数值</span></span><br><span class="line">        System.out.println(between.toDays());</span><br><span class="line">        <span class="comment">// 获取时间差的小时值</span></span><br><span class="line">        System.out.println(between.toHours());</span><br><span class="line">        <span class="comment">// 获取时间差的分钟值</span></span><br><span class="line">        System.out.println(between.toMinutes());</span><br><span class="line">        <span class="comment">// 获取时间差的秒数值</span></span><br><span class="line">        System.out.println(between.getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10000</span><br><span class="line">10000000000</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="天、时、分、秒"><a href="#天、时、分、秒" class="headerlink" title="天、时、分、秒"></a>天、时、分、秒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        LocalDateTime d1 = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 当前时间延后90000s</span></span><br><span class="line">        LocalDateTime d2 = d1.plusSeconds(<span class="number">90000</span>);</span><br><span class="line">        <span class="comment">// 获取两个时间之间隔了几个半天</span></span><br><span class="line">        <span class="keyword">long</span> b1 = ChronoUnit.HALF_DAYS.between(d1, d2);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="comment">// 获取两个时间之间隔了几个小时</span></span><br><span class="line">        <span class="keyword">long</span> b2 = ChronoUnit.HOURS.between(d1, d2);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        <span class="comment">// 获取两个时间之间隔了多少毫秒</span></span><br><span class="line">        <span class="keyword">long</span> b3 = ChronoUnit.MILLIS.between(d1, d2);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">25</span><br><span class="line">90000000</span><br></pre></td></tr></table></figure><h3 id="年、月、日"><a href="#年、月、日" class="headerlink" title="年、月、日"></a>年、月、日</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate d1 = LocalDate.now();</span><br><span class="line">        <span class="comment">// 构建2018-10-01</span></span><br><span class="line">        LocalDate d2 = LocalDate.of(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取两个日期的差值</span></span><br><span class="line">        Period between = Period.between(d1, d2);</span><br><span class="line">        <span class="comment">// 获取两个日期隔了多少年</span></span><br><span class="line">        System.out.println(between.getYears());</span><br><span class="line">        <span class="comment">// 获取两个日期隔了多少月</span></span><br><span class="line">        System.out.println(between.getMonths());</span><br><span class="line">        <span class="comment">// 获取两个日期隔了多少天</span></span><br><span class="line">        System.out.println(between.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">26</span><br></pre></td></tr></table></figure><h2 id="获取某天的日期"><a href="#获取某天的日期" class="headerlink" title="获取某天的日期"></a>获取某天的日期</h2><p>比如有时候我们还会有这样的需求，获取当前日期所在的周一，那么这种又该怎么处理呢；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      LocalDate now = LocalDate.now();</span><br><span class="line">      LocalDate date = now.with(DayOfWeek.MONDAY);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2017-09-04</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，常用的用法就讲到这里，<code>time</code>包下的类搭配起来可以有更多的用法，需要同学们在使用过程中去摸索了，这里只是列举了部分常见的用法，可能在日常开发中能够用到，这也是我平时在开发中常用到的一些<code>API</code>。这里再提供两个工具类供参考一些格式化时间的方式以及一些常用转换处理，<a href="https://github.com/felixu1992/common-repo/tree/master/felixu-common/src/main/java/top/felixu/common/date" target="_blank" rel="noopener">戳这里查看详情</a>。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
