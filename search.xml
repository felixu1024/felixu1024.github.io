<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Java 8 新时间 API</title>
      <link href="/2019/10/21/java-2019-10-21-Java-8-%E6%96%B0%E6%97%B6%E9%97%B4-API/"/>
      <url>/2019/10/21/java-2019-10-21-Java-8-%E6%96%B0%E6%97%B6%E9%97%B4-API/</url>
      <content type="html"><![CDATA[<p><code>Java 8</code>日期/时间API是<code>JSR-310</code>的实现，它的实现目标是克服旧的日期时间实现中所有的缺陷。利用它可以更加方便我们去处理时间和日期的计算等问题。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>新的日期/时间<code>API</code>它遵循以下的设计原则：</p><ul><li><strong>不变性</strong>：在新的日期/时间<code>API</code>中，所有的类都被设计成不可变的，这在多线程环境下也是没有问题的。</li><li><strong>关注点分离</strong>：在<code>Java8</code>中，相比于之前旧的时间和日历类，较大的改变是将人可读的日期时间和机器时间(<code>unix timestamp</code>)明确分离，为日期(<code>Date</code>)、时间(<code>Time</code>)、日期时间(<code>DateTime</code>)、时间戳(<code>unix timestamp</code>)以及时区定义了不同的类。</li><li><strong>清晰</strong>：在所有的类中，方法都被明确定义用以完成相同的行为。举个例子，要拿到当前实例我们可以使用<code>now()</code>方法，在所有的类中都定义了<code>format()</code>和<code>parse()</code>方法，而不是像以前那样专门有一个独立的类。为了更好的处理问题，所有的类都使用了工厂模式和策略模式，一旦你使用了其中某个类的方法，与其他类协同工作并不困难。</li><li><strong>实用操作</strong>：所有新的日期/时间API类都实现了一系列方法用以完成通用的任务，如：加、减、格式化、解析、从日期/时间中提取单独部分，等等。</li><li><strong>可扩展性</strong>： 新的日期/时间<code>API</code>是工作在<code>ISO-8601</code>日历系统上的，但我们也可以将其应用在非<code>ISO</code>的日历上。</li></ul><h1 id="time包"><a href="#time包" class="headerlink" title="time包"></a>time包</h1><p><code>java.time</code>包中的是类是不可变且线程安全的。新的时间及日期API位于<code>java.time</code>中。下面是一些比较常用的类： </p><ul><li><code>Instant</code>：表示时间戳</li><li><code>LocalDate</code>：不包含具体时间点的日期</li><li><code>LocalTime</code>：不包含日期的时间点</li><li><code>LocalDateTime</code>：具体的日期时间点，不带时区</li><li><code>ZonedDateTime</code>：包含时区的完整的日期时间点，偏移量是以<code>UTC/</code>格林威治时间为基准的。 </li></ul><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>对于这些类，它们都有以下一些常用的方法：</p><ul><li><code>of()</code>：静态工厂方法。</li><li><code>parse()</code>：静态工厂方法，关注于解析。</li><li><code>get*()</code>：获取某些东西的值。</li><li><code>is*()</code>：检查某些东西的是否是<code>true</code>。</li><li><code>with*()</code>：不可变的<code>setter</code>等价物。</li><li><code>plus*()</code>：加一些量到某个对象。</li><li><code>minus*()</code>：从某个对象减去一些量。</li><li><code>to*()</code>：转换到另一个类型。</li><li><code>at*()</code>：把这个对象与另一个对象组合起来，例如： date.atTime(time)。</li></ul><h2 id="日期-时间计算"><a href="#日期-时间计算" class="headerlink" title="日期/时间计算"></a>日期/时间计算</h2><h3 id="获取当前时间-日期"><a href="#获取当前时间-日期" class="headerlink" title="获取当前时间/日期"></a>获取当前时间/日期</h3><p>以前有<code>Date</code>类可以获取当前时间，有<code>Calendar</code>类来做日历相关操作。而在<code>Java 8</code>中，提供了多个类来获取当前的日期、时间、时间戳等信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        System.out.println(LocalDate.now());</span><br><span class="line">        <span class="comment">// 获取当前时间点</span></span><br><span class="line">        System.out.println(LocalTime.now());</span><br><span class="line">        <span class="comment">// 获取当前时间点去掉纳秒</span></span><br><span class="line">        System.out.println(LocalTime.now().withNano(<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 获取当前的日期时间</span></span><br><span class="line">        System.out.println(LocalDateTime.now());</span><br><span class="line">        <span class="comment">// 获取当前年</span></span><br><span class="line">        System.out.println(LocalDate.now().getYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2018-09-04</span><br><span class="line">22:03:49.502</span><br><span class="line">22:03:49</span><br><span class="line">2018-09-04T22:03:49.502</span><br><span class="line">2018</span><br></pre></td></tr></table></figure><h3 id="判断两个日期是否相等"><a href="#判断两个日期是否相等" class="headerlink" title="判断两个日期是否相等"></a>判断两个日期是否相等</h3><p>在<code>Java 8</code>的众多类中，它们都重写了<code>toString()</code>方法。所以对于日期是否相同的判断，我们可以直接使用它的<code>equals()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        <span class="comment">// 构建2018-09-03</span></span><br><span class="line">        LocalDate date = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 判断是否相等</span></span><br><span class="line">        System.out.println(today.equals(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><p>当然这里也可以用上面提到的<code>is*()</code>方法，比如这里我们也可以这样比较是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        <span class="comment">// 构建2018-09-03</span></span><br><span class="line">        LocalDate date = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 判断是否相等</span></span><br><span class="line">        System.out.println(today.isEqual(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样会输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="判断一个日期是否在另一个日期之前"><a href="#判断一个日期是否在另一个日期之前" class="headerlink" title="判断一个日期是否在另一个日期之前"></a>判断一个日期是否在另一个日期之前</h3><p>有时候可能会有这样的需求，需要判断一个日期在另一个日期的前面还是后面，这时候就会用到<code>isBefore()</code>和<code>isAfter()</code>方法，这样就可以方便的作出判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建2018-09-04</span></span><br><span class="line">        LocalDate d1 = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 构建2018-09-03</span></span><br><span class="line">        LocalDate d2 = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 判断d1是否在d2后面</span></span><br><span class="line">        System.out.println(d1.isAfter(d2));</span><br><span class="line">        <span class="comment">// 判断d1是否在d2前面</span></span><br><span class="line">        System.out.println(d1.isBefore(d2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>可以看到我们直接可以使用<code>isBefore()</code>和<code>isAfter()</code>来判断两个日期谁前谁后了，而不需要像以前使用<code>Calendar</code>来进行麻烦的操作了。</p><h3 id="检查重复日期"><a href="#检查重复日期" class="headerlink" title="检查重复日期"></a>检查重复日期</h3><p>对于一些特定的日期，比如生日、纪念日等，我们可以轻易来判断某一日期是不是我们需要的特定日期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LocalDate dateOfBirth = LocalDate.of(<span class="number">1992</span>, <span class="number">9</span>, <span class="number">4</span>);</span><br><span class="line">        MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth());</span><br><span class="line">        MonthDay currentMonthDay = MonthDay.from(LocalDate.now());</span><br><span class="line">        <span class="keyword">if</span>(currentMonthDay.equals(birthday))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Happy Birthday !"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Sorry, today is not your birthday！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Happy Birthday !</span><br></pre></td></tr></table></figure><h3 id="判断某个日期是不是周几"><a href="#判断某个日期是不是周几" class="headerlink" title="判断某个日期是不是周几"></a>判断某个日期是不是周几</h3><p>同样，我们可以很方便的来判断某天是周几。<code>DayOfWeek</code>构建的是周几，然后使用<code>from()</code>方法，来构建某一日期为周几，这样我们就可以轻松判断出某一日期是不是周几，同样也可以轻松知道今天是周几。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DayOfWeek dayOfWeek = DayOfWeek.of(<span class="number">2</span>);</span><br><span class="line">        DayOfWeek from = DayOfWeek.from(LocalDate.now());</span><br><span class="line">        System.out.println(from.equals(dayOfWeek));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="延迟或者推前时间"><a href="#延迟或者推前时间" class="headerlink" title="延迟或者推前时间"></a>延迟或者推前时间</h3><p>有时候我们可能会需要用到一些日期计算，比如，昨天，前天，明天，一周前，一年前等。在<code>Java 8中</code>可以轻松实现，因为这些类中已经提供了相关方法。<code>plus*()</code>表示往后算，<code>minus*()</code>表示往前算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate today = LocalDate.now();</span><br><span class="line">        System.out.println(today);</span><br><span class="line">        <span class="comment">// 推前一天</span></span><br><span class="line">        System.out.println(today.minusDays(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 延后一天</span></span><br><span class="line">        System.out.println(today.plusDays(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09-04</span><br><span class="line">2018-09-03</span><br><span class="line">2018-09-05</span><br></pre></td></tr></table></figure><p>当然对于<code>plus*()</code>和<code>minus*()</code>也可以接受负数，来表示相反的意思，比如<code>today.plusDays(-1)</code>也就是等价于<code>today.minusDays(1)</code>。</p><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p><code>Java 8</code>提供了时钟类，利用时钟类可以实现和<code>System.currentTimeMillis()</code>一样的功能，还能够获取当前时区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        System.out.println(Clock.systemUTC().millis());</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">        <span class="comment">// 获取当前系统默认时区</span></span><br><span class="line">        System.out.println(Clock.systemDefaultZone().getZone());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1536101287531</span><br><span class="line">1536101287531</span><br><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure><h3 id="检查闰年"><a href="#检查闰年" class="headerlink" title="检查闰年"></a>检查闰年</h3><p>可以使用<code>isLeapYear()</code>方法直接判断是否为闰年，而不用我们再自己去计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(LocalDate.of(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>).isLeapYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure><h3 id="带时区计算"><a href="#带时区计算" class="headerlink" title="带时区计算"></a>带时区计算</h3><p><code>Java 8</code>不仅将日期和时间进行了分离，同时还有时区。现在已经有好几组与时区相关的类了，比如<code>ZonId</code>代表的是某个特定的时区，而<code>ZonedDateTime</code>代表的是带时区的时间。它等同于<code>Java 8</code>以前的<code>GregorianCalendar</code>类。使用这个类，你可以将本地时间转换成另一个时区中的对应时间。用<code>ZoneOffset</code>类来代表某个时区，比如印度是<code>GMT</code>或者<code>UTC5:30</code>，你可以使用它的静态方法<code>ZoneOffset.of()</code>方法来获取对应的时区。只要获取到了这个偏移量，你就可以拿<code>LocalDateTime</code>和这个偏移量创建出一个<code>OffsetDateTime</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 设置时区</span></span><br><span class="line">        ZonedDateTime zonedDateTime = ZonedDateTime.of(now, ZoneId.of(<span class="string">"Australia/Darwin"</span>));</span><br><span class="line">        System.out.println(<span class="string">"Current date and time in a particular timezone : "</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建一个时间</span></span><br><span class="line">        LocalDateTime datetime = LocalDateTime.of(<span class="number">2018</span>, Month.SEPTEMBER, <span class="number">5</span>, <span class="number">7</span>, <span class="number">50</span>);</span><br><span class="line">        <span class="comment">// 设置偏移量</span></span><br><span class="line">        ZoneOffset offset = ZoneOffset.of(<span class="string">"+05:30"</span>);</span><br><span class="line">        <span class="comment">// 构建带偏移量的日期和时间</span></span><br><span class="line">        OffsetDateTime date = OffsetDateTime.of(datetime, offset);</span><br><span class="line">        System.out.println(<span class="string">"Date and Time with timezone offset in Java : "</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Current date and time in a particular timezone : 2018-09-05T07:50:43.187+09:30[Australia/Darwin]</span><br><span class="line">Date and Time with timezone offset in Java : 2018-09-05T07:50+05:30</span><br></pre></td></tr></table></figure><p><code>OffSetDateTime</code>主要是给机器来理解的，如果是给人看的，可以使用<code>ZoneDateTime</code>类。</p><h3 id="固定日期"><a href="#固定日期" class="headerlink" title="固定日期"></a>固定日期</h3><p>在前面我们用过一个<code>MonthDay</code>的类，用来构建特定的几月几日。这里用到了另一个<code>YearMonth</code>，它表示某年某月，我们可以它来知道某年某月有多少天，使用<code>YearMonth</code>的<code>lengthOfMonth()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前年月</span></span><br><span class="line">        YearMonth current = YearMonth.now();</span><br><span class="line">        System.out.println(current);</span><br><span class="line">        <span class="comment">// 获取这个月有多少天</span></span><br><span class="line">        System.out.println(current.lengthOfMonth());</span><br><span class="line">        <span class="comment">// 构建一个固定日期</span></span><br><span class="line">        YearMonth expire = YearMonth.of(<span class="number">2018</span>, Month.NOVEMBER);</span><br><span class="line">        System.out.println(expire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-09</span><br><span class="line">30</span><br><span class="line">2018-11</span><br></pre></td></tr></table></figure><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><p>在<code>Java 8</code>以前我们格式化时间就需要去构建一个<code>SimpleDateFormat</code>，而这个东西还是个线程不安全的，错误的使用常常会带来一些问题。<code>Java 8</code>为我们提供了一个更方便更安全的格式化类，它就是<code>DateTimeFormatter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String dayAfterTomorrow = <span class="string">"20180905"</span>;</span><br><span class="line">        LocalDate formatted = LocalDate.parse(dayAfterTomorrow,</span><br><span class="line">                DateTimeFormatter.BASIC_ISO_DATE);</span><br><span class="line">        System.out.printf(<span class="string">"Date generated from String %s is %s %n"</span>, dayAfterTomorrow, formatted);</span><br><span class="line"></span><br><span class="line">        String goodFriday = <span class="string">"Sep 05 2018"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy"</span>);</span><br><span class="line">            LocalDate holiday = LocalDate.parse(goodFriday, formatter);</span><br><span class="line">            System.out.printf(<span class="string">"Successfully parsed String %s, date is %s%n"</span>, goodFriday, holiday);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DateTimeParseException ex) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s is not parsable!%n"</span>, goodFriday);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalDateTime arrivalDate = LocalDateTime.now();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateTimeFormatter format = DateTimeFormatter.ofPattern(<span class="string">"MMM dd yyyy hh:mm a"</span>);</span><br><span class="line">            String landing = arrivalDate.format(format);</span><br><span class="line">            System.out.printf(<span class="string">"Arriving at : %s %n"</span>, landing);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DateTimeException ex) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s can't be formatted!%n"</span>, arrivalDate);</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date generated from String 20180905 is 2018-09-05 </span><br><span class="line">Successfully parsed String Sep 05 2018, date is 2018-09-05</span><br><span class="line">Arriving at : Sep 06 2018 07:47 AM</span><br></pre></td></tr></table></figure><p>更多的格式化方法可以<a href="https://github.com/felixu1992/common-repo/blob/master/felixu-common/src/main/java/top/felixu/common/utils/DateFormatUtils.java" target="_blank" rel="noopener">戳这里</a>。</p><h2 id="计算时间间隔"><a href="#计算时间间隔" class="headerlink" title="计算时间间隔"></a>计算时间间隔</h2><p><code>Java 8</code>为我们提供了三个类来方便计算时间间隔，分别是</p><ul><li><code>Duration</code>：计算秒、纳秒</li><li><code>ChronoUnit</code>：计算天、时、分、秒</li><li><code>Period</code>：计算年、月、日</li></ul><h3 id="秒、纳秒"><a href="#秒、纳秒" class="headerlink" title="秒、纳秒"></a>秒、纳秒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间戳</span></span><br><span class="line">        Instant i1 = Instant.now();</span><br><span class="line">        <span class="comment">// 当前时间推后10s</span></span><br><span class="line">        Instant i2 = i1.plusSeconds(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 获取时间差</span></span><br><span class="line">        Duration between = Duration.between(i1, i2);</span><br><span class="line">        <span class="comment">// 获取时间差的毫秒值</span></span><br><span class="line">        System.out.println(between.toMillis());</span><br><span class="line">        <span class="comment">// 获取时间差的纳秒值</span></span><br><span class="line">        System.out.println(between.toNanos());</span><br><span class="line">        <span class="comment">// 获取时间差的天数值</span></span><br><span class="line">        System.out.println(between.toDays());</span><br><span class="line">        <span class="comment">// 获取时间差的小时值</span></span><br><span class="line">        System.out.println(between.toHours());</span><br><span class="line">        <span class="comment">// 获取时间差的分钟值</span></span><br><span class="line">        System.out.println(between.toMinutes());</span><br><span class="line">        <span class="comment">// 获取时间差的秒数值</span></span><br><span class="line">        System.out.println(between.getSeconds());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10000</span><br><span class="line">10000000000</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="天、时、分、秒"><a href="#天、时、分、秒" class="headerlink" title="天、时、分、秒"></a>天、时、分、秒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        LocalDateTime d1 = LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 当前时间延后90000s</span></span><br><span class="line">        LocalDateTime d2 = d1.plusSeconds(<span class="number">90000</span>);</span><br><span class="line">        <span class="comment">// 获取两个时间之间隔了几个半天</span></span><br><span class="line">        <span class="keyword">long</span> b1 = ChronoUnit.HALF_DAYS.between(d1, d2);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">        <span class="comment">// 获取两个时间之间隔了几个小时</span></span><br><span class="line">        <span class="keyword">long</span> b2 = ChronoUnit.HOURS.between(d1, d2);</span><br><span class="line">        System.out.println(b2);</span><br><span class="line">        <span class="comment">// 获取两个时间之间隔了多少毫秒</span></span><br><span class="line">        <span class="keyword">long</span> b3 = ChronoUnit.MILLIS.between(d1, d2);</span><br><span class="line">        System.out.println(b3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">25</span><br><span class="line">90000000</span><br></pre></td></tr></table></figure><h3 id="年、月、日"><a href="#年、月、日" class="headerlink" title="年、月、日"></a>年、月、日</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前日期</span></span><br><span class="line">        LocalDate d1 = LocalDate.now();</span><br><span class="line">        <span class="comment">// 构建2018-10-01</span></span><br><span class="line">        LocalDate d2 = LocalDate.of(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取两个日期的差值</span></span><br><span class="line">        Period between = Period.between(d1, d2);</span><br><span class="line">        <span class="comment">// 获取两个日期隔了多少年</span></span><br><span class="line">        System.out.println(between.getYears());</span><br><span class="line">        <span class="comment">// 获取两个日期隔了多少月</span></span><br><span class="line">        System.out.println(between.getMonths());</span><br><span class="line">        <span class="comment">// 获取两个日期隔了多少天</span></span><br><span class="line">        System.out.println(between.getDays());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">26</span><br></pre></td></tr></table></figure><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>当然<code>time</code>包下的<code>API</code>肯定不止这些，更多的需要我们自己在使用中更多的去发掘，这里只是列举了一些比较常用的方法。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 8 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IDEA常用快捷键(Mac版)</title>
      <link href="/2019/09/24/ide-2019-09-24-Mac%E7%89%88IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2019/09/24/ide-2019-09-24-Mac%E7%89%88IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<h2 id="Mac键盘符号和修饰键说明"><a href="#Mac键盘符号和修饰键说明" class="headerlink" title="Mac键盘符号和修饰键说明"></a>Mac键盘符号和修饰键说明</h2><p><strong>⌘</strong> <code>Command</code><br><strong>⇧</strong> <code>Shift</code><br><strong>⌥</strong> <code>Option</code><br><strong>⌃</strong> <code>Control</code><br><strong>↩︎</strong> <code>Return/Enter</code><br><strong>⌫</strong> <code>Delete</code><br><strong>⌦</strong> <code>向前删除键(Fn+Delete)</code><br><strong>↑</strong> <code>上箭头</code><br><strong>↓</strong> <code>下箭头</code><br><strong>←</strong> <code>左箭头</code><br><strong>→</strong> <code>右箭头</code><br><strong>⇞</strong> <code>Page Up(Fn+↑)</code><br><strong>⇟</strong> <code>Page Down(Fn+↓)</code><br><strong>Home</strong> <code>Fn + ←</code><br><strong>End</strong> <code>Fn + →</code><br><strong>⇥</strong> <code>右制表符(Tab键)</code><br><strong>⇤</strong> <code>左制表符(Shift+Tab)</code><br><strong>⎋</strong> <code>Escape(Esc)</code>    </p><h2 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>全局查找</strong>：<code>Alt+F7</code>全局查找在哪里使用<br><strong>全局查找选中字符</strong>：<code>Command+Alt+F7</code>查找选中的字符在工程中出现的地方，可以不是方法变量类等，这个和上面的有区别的<br><strong>在当前文件中查找某个字符串</strong>：<code>Command＋F7</code>可以查询当前元素在当前文件中的引用，然后按F3可以选择 ，功能基本同上<br><strong>高亮选中的文本</strong>：选中文本，按<code>Command+Shift+F7</code>高亮显示所有该文本，按Esc高亮消失<br><strong>查找相同文本并高亮</strong>：选中文本，按<code>Alt+F3</code>逐个往下查找相同文本，并高亮显示，<code>shift+f3</code>就是往上找<br><strong>GET/SET方法</strong>：<code>Ctrl+Enter</code>出现生成GET/SET方法的界面<br><strong>任意处切换到下一行</strong>：<code>Shift+Enter</code>任意处往下面添加一行空行并切换到下一行<br><strong>查找类</strong>：<code>Command+N</code>查找类<br><strong>查找文件</strong>：<code>Command+shift+N</code>查找文件<br><strong>当前文件中搜索并替换</strong>：<code>Command+R</code>替换<br><strong>在整个工程或者某个目录下替换变量</strong>：<code>Ctrl+Shift+R</code>可以在整个工程或着某个目录下面替换变量<br><strong>删除当前行</strong>：<code>Command+Y</code> 删除当前光标所在行<br><strong>复制当前行到下一行</strong>：<code>Command+D</code>将当前光标所在行复制到下一行<br><strong>合并多行到一行</strong>：<code>Ctrl+Shift+J</code>将多行连接成一行，会去掉空行<br><strong>自动生成一些代码结构</strong>：<code>Command+J</code>自动生成一些代码结构，比如for循环之类的<br><strong>查找变量来源或在哪里被使用</strong>：<code>Command+B</code>查找变量的来源或者变量在哪里被使用，同<code>F4</code>相似，查找变量来源<br><strong>查找变量所属类</strong>：<code>Ctrl+Shift+B</code>查找变量所属的类<br><strong>定位当前行和列或跳转至某行某列</strong>：<code>Command+G</code>定位当前所在的行和列，或者跳转至某行某列<br><strong>在当前文件中查找</strong>：<code>Command+F</code>在当前文件里查找文本，<code>F3</code>向下看，<code>Shift+F3</code>向上看<br><strong>在整个工程或者某个目录下查找变量</strong>：<code>Ctrl+Shift+F</code>可以在整个工程或着某个目录下面查找变量<br><strong>查看最近修改的文件</strong>：<code>Alt+Shift+C</code>查看最近修改的文件<br><strong>查看最近打开过的文件</strong>：<code>command+E</code>查看最近打开的文件<br><strong>万能键</strong>：<code>alt+enter</code>导入包，自动修改，自动补全啊，很多功能<br><strong>格式化代码</strong>：<code>Command+Alt+L</code>格式化代码<br><strong>自动缩进</strong>：<code>Command+Alt+I</code>自动缩进，不用多次使用tab或着backspace键，也是比较方便的<br><strong>代码补全</strong>：<code>Ctrl+Shift+Space</code>代码补全，这个会判断可能用到的，这个代码补全和代码提示是不一样的，可能和系统快捷键冲突，反正我是没反应<br><strong>方法参数提示</strong>：<code>Command+P</code>方法参数提示<br><strong>将选中代码放入代码块中</strong>：<code>Command+Alt+T</code>把选中的代码放在try{}，if{}，else{}里<br><strong>多文本复制</strong>：<code>Command+Shift+V</code>会出来之前复制过的内容列表，可以复制多个文本<br><strong>大小写转换</strong>：<code>Command+Shift+U</code>大小写转换<br><strong>查找文件所在位置</strong>：<code>Alt+F1</code>查找文件所在目录位置<br><strong>单行注释</strong>：<code>Command+/</code>注释一行或着多行 //<br><strong>多行注释</strong>：<code>Ctrl+Shift+/</code>多行注释/*…*/<br><strong>返回上次编辑的位置</strong>：<code>Command+alt+左右箭头</code>返回上次编辑的位置<br><strong>重命名</strong>：<code>Shift+F6</code>重命名<br><strong>上移或下移代码</strong>：<code>Command+Shift+上下箭头</code>把代码上移或着下移<br><strong>跳至大括号开头或结尾</strong>：<code>Command+[或]</code>可以跳到大括号的开头结尾，毫无效果<br><strong>显示当前类中所有方法</strong>：<code>Command+f12</code>可以显示当前类中所有方法<br><strong>跳转至接口或抽象方法的实现代码</strong>：<code>Command+Alt+B</code>可以跳转至接口的实现类，接口或抽象方法的实现方法<br><strong>debug时查看选中值</strong>：<code>Alt+F8</code>debug时选中查看值<br><strong>debug跳到下一步</strong>：<code>F8</code>跳到下一步<br><strong>debug跳至下一个断点</strong>：<code>Shift+F8</code>跳到下一个断点<br><strong>debug中进入代码</strong>：<code>F7</code>进入到代码<br><strong>debug强行进入代码</strong>：<code>Alt+Shift+F7</code>强制进入代码<br><strong>debug运行</strong>：<code>Ctrl+Shift+F9</code> debug运行java类<br><strong>非debug运行</strong>：<code>Ctrl+Shift+F10</code>正常运行java类<br><strong>停止运行</strong>：<code>Command+F2</code>停止运行           </p>]]></content>
      
      <categories>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>傻瓜式安装V2Ray</title>
      <link href="/2019/09/24/essay-2019-09-24-%E5%82%BB%E7%93%9C%E5%BC%8F%E6%90%AD%E5%BB%BAV2Ray/"/>
      <url>/2019/09/24/essay-2019-09-24-%E5%82%BB%E7%93%9C%E5%BC%8F%E6%90%AD%E5%BB%BAV2Ray/</url>
      <content type="html"><![CDATA[<h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><p>有众多的网站可以购买国外的一些<code>VPS</code>用于搭建我们自己的梯子，这里就不在详细介绍其过程了。</p><p>比如<a href="https://wwww.vultr.com" target="_blank" rel="noopener">Vultr</a>、<a href="https://m.do.co/c/ed93cb8d1263" target="_blank" rel="noopener">Digitalocean</a>等等</p><h1 id="搭建V2Ray"><a href="#搭建V2Ray" class="headerlink" title="搭建V2Ray"></a>搭建V2Ray</h1><ol><li><p><code>VPS</code>购买完成登陆到机器上，不过工具也好，<code>SSH</code>也好，都可以。</p></li><li><p>执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/v2ray.sh)</span><br></pre></td></tr></table></figure></li><li><p>回车一顿傻瓜式操作</p></li><li><p>等待安装完毕就行了</p></li></ol><p><strong>注意：</strong>建议不要开<code>SS</code>，毕竟那个鬼东西还是走<code>Socks5</code>协议，我开了之后基本一天需要换个端口。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><code>V2Ray</code>的支持还是比较不错的，各种平台都有相关的客户端，比如</p><ul><li>Mac有V2RayX</li><li>Win有V2RayN</li><li>IOS可以用小火箭，或者是<code>Kitsunbeni</code></li><li>安卓。。。不知道没设备，但是安卓相对来说应该更多</li></ul><h1 id="开启BBR加速"><a href="#开启BBR加速" class="headerlink" title="开启BBR加速"></a>开启BBR加速</h1><p><a href="https://www.noobyy.com/863.html" target="_blank" rel="noopener">See</a></p>]]></content>
      
      <categories>
          
          <category> Essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Essay </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
